{"version":3,"sources":["components/TodoItem/TodoItem.module.css","components/Header/Header.js","components/Practice/Practice.js","components/TodoCount/TodoCount.js","components/TodoItem/TodoItem.js","components/TodoList/TodoList.js","components/InputTodo/InputTodo.js","components/Practice/AlertButton.js","pages/About.js","pages/NotMatch.js","components/Navbar/Navbar.js","pages/Contact.js","components/TodoContainer/TodoContainer.js","index.js"],"names":["module","exports","Header","style","padding","lineHeight","fontSize","fontWeight","marginBottom","color","textTransform","textAlign","React","Component","TodoCount","props","completedTodos","todosProp","filter","todoObject","completed","length","TodoItem","className","styles","item","checkbox","type","checked","onChange","handleChangeProp","id","display","onDoubleClick","console","log","fontStyle","opacity","textDecoration","children","onClick","delTodoProp","TodoList","this","map","todo","title","InputTodo","useState","setTitle","onSubmit","e","preventDefault","trim","addTodoProp","alert","name","placeholder","value","target","size","About","NotMatch","Navbar","activeClass","activeClassName","to","exact","Contact","TodoContainer","handleChange","setState","todos","state","todoObj","addTodo","newTodo","uuidv4","delTodo","newTodos","temp","localStorage","getItem","loadedTodos","JSON","parse","previousProps","previousState","stringify","setItem","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.106653c7.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"TodoItem_item__2olry\",\"checkbox\":\"TodoItem_checkbox__3UTxr\"};","const Header = () => {\n  \n  const h1Style = {\n    fontSize: \"6rem\",\n    fontWeight: \"600\",\n    marginBottom: \"2rem\",\n    lineHeight: \"1em\",\n    color: \"#ececec\",\n    textTransform: \"lowercase\",\n    textAlign: \"center\",\n  };\n\n  return (\n    <header style={{\n      padding: \"20px 0\",\n      lineHeight: \"1.5em\"\n    }}>\n      <h1 style={h1Style}>\n        todos\n      </h1>\n    </header>\n  )\n}\n\nexport default Header;","import React, { useState } from \"react\";\n\nfunction Practice() {\n\n  const [someText, setSomeText] = useState(\"Hallo Reacter!\");\n  const [names, setNames] = useState([\"Manuel\", \"Christian\", \"Alina\"]);\n  \n  const [text, setText] = useState(\"Ich bin ein State als Hook!\");\n\n  //Alternative: ein state mit Object\n  const [state, setState] = useState({\n    title: \"\",\n    text: \"Ich bin ein 'Object-State' als Hook!\"\n  });\n\n\n\n  const handleWordChange = () => {\n    setSomeText(\"Hallo Welt!\");\n  }\n\n  const nameChanger = () => {\n\n    const newNamesArray = names.map(name => {\n      return `Hello ${name}`\n    })\n    setNames(newNamesArray);\n  }\n\n\n  return (\n    <div className=\"nur-zum-lernen\" style={{ marginTop: \"20px\" }}>\n      <h3>Nur zum üben</h3>\n      <p>{someText}</p>\n      <button\n        onClick={handleWordChange}\n      >\n        Ändere oberen Text\n      </button>\n      <ul>\n        {names.map((name, i) => {\n          return <li key={i}>{name}</li>\n        })}\n        {/* { [<li>Manuel</li>, <li>Christian</li>, <li>Alina</li>] } */}\n      </ul>\n      <button\n        onClick={nameChanger}\n      >\n        Hello!\n      </button>\n      <br />\n      <hr />\n      <br />\n      <span\n        onClick={() => { setText('Ich wurde angeklickt 👽') }}\n      >\n        {text}\n      </span>\n      <span\n        onClick={() => {\n          setState({\n            ...state, //destructering notwendig bei useState, da nicht automatisch gemerged wird\n            text: 'ich wurde angeklickt'\n          })\n        }}\n      >\n        {state.text}\n      </span>\n    </div>\n  );\n}\n\nclass PracticeClass extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      someText: \"Hallo Reacter!\",\n      names: [\"Manuel\", \"Christian\", \"Alina\"]\n    }\n  }\n\n  handleWordChange = () => {\n    this.setState({\n      someText: \"Hallo Welt!\"\n    });\n  }\n\n  nameChanger = () => {\n    this.setState({\n      names: this.state.names.map(name => {\n        return `Hello ${name}`\n      })\n    });\n\n    // ToDo in Zukunft: Eigentlich auch hier Callback benutzen\n  }\n\n  render() {\n    return (\n      <div className=\"nur-zum-lernen\">\n        <h3>Nur zum üben</h3>\n        <p>{this.state.someText}</p>\n        <button\n          onClick={this.handleWordChange}\n        >\n          Ändere oberen Text\n        </button>\n        <ul>\n          {this.state.names.map((name, i) => {\n            return <li key={i}>{name}</li>\n          })}\n          {/* { [<li>Manuel</li>, <li>Christian</li>, <li>Alina</li>] } */}\n        </ul>\n        <button\n          onClick={this.nameChanger}\n        >\n          Hello!\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default Practice;\n\n/*\nHinweis:\n\nWir benutzen in der render Funktion wieder map. DAher brauchen wir\neinen key. In diesem Fall benutzen wir den index als key. Das ist\neigentlich keine gute Praxis, wenn wir z.B. die Namen löschen\nund erweitern würden. In diesem Fall würde sich der INdex nämlich ändern\nund plötzlich hätte vielleicht ein Element eine andere ID.\nMehr dazu: https://programmingwithmosh.com/react/why-do-i-need-keys-in-react-lists/\n\nIn unserem Fall hier ist es aber ok\n\n*/","const TodoCount = (props) => {\n\n  // filter erstellt uns hier ein neues Array mit Objecten (also Todos)\n  // die \"completed:true\" haben\n  const completedTodos = props.todosProp.filter( todoObject => {\n    return todoObject.completed === true;\n  });\n\n  return (\n    <p>\n      {completedTodos.length}/{props.todosProp.length} Todos erledigt\n    </p>\n  );\n};\n\nexport default TodoCount;","import {Component} from \"react\";\nimport { FaTrash } from \"react-icons/fa\"\nimport styles from \"./TodoItem.module.css\";\n\nconst TodoItem = (props) => {\n\n  const completedStyle = {\n    fontStyle: \"italic\",\n    color: \"#595959\",\n    opacity: 0.4,\n    textDecoration: \"line-through\",\n  }\n\n  // Alternative zum ternären Operator hinsichtlich completedStyle\n  // siehe unten\n\n  const handleEdit = () => {\n    console.log('edit mode activated');\n    // In Zukunft (optional): implementieren\n    // Tutorial: https://ibaslogic.com/how-to-edit-todos-items-in-react/\n\n  };\n\n  return (\n    <li className={styles.item}>\n      <input\n        className={styles.checkbox}\n        type=\"checkbox\" \n        checked ={props.completed}\n        onChange={ ()=>{props.handleChangeProp(props.id)} }\n      />\n      <div style={{display:\"inline-block\"}} onDoubleClick={handleEdit}>\n        <span style={props.completed ? completedStyle : null}>\n          {props.children}\n        </span>\n        {/* Hier später Input Element hinzufügen (für edit Funktion) */}\n      </div>  \n      \n      <button\n        onClick={ () => {props.delTodoProp(props.id)} }\n      >\n        <FaTrash style={{ color: \"orangered\", fontSize: \"16px\" }} />\n      </button>\n    </li>\n  )\n};\n\n\n// nachfolgend: Componente als class, um componentWillUnmount()\n// zu zeigen\nclass TodoItemWithLifecycleMethods extends Component {\n\n\n  // Alternative zum ternären Operator hinsichtlich completedStyle\n  // siehe unten\n\n  handleEdit = () => {\n    console.log('edit mode activated');\n    // In Zukunft (optional): implementieren\n    // Tutorial: https://ibaslogic.com/how-to-edit-todos-items-in-react/\n\n  }\n\n  componentDidMount() {\n    // Hier z.B. setIntervall starten\n\n  }\n\n  componentWillUnmount() {\n    // wird ausgeführt, before die Komponente entfernt wird\n    alert('TodoItem wird nun entfernt');\n    // Um \"Aufräumarbeiten\" durchzuführen\n    // z.B. setIntervall anzubrechen\n  }\n\n  render() {\n    const completedStyle = {\n      fontStyle: \"italic\",\n      color: \"#595959\",\n      opacity: 0.4,\n      textDecoration: \"line-through\",\n    }\n    return (\n      <li className={styles.item}>\n        <input\n          className={styles.checkbox}\n          type=\"checkbox\" \n          checked ={this.props.completed}\n          onChange={ ()=>{this.props.handleChangeProp(this.props.id)} }\n        />\n        <div style={{display:\"inline-block\"}} onDoubleClick={this.handleEdit}>\n          <span style={this.props.completed ? completedStyle : null}>\n            {this.props.children}\n          </span>\n          {/* Hier später Input Element hinzufügen (für edit Funktion) */}\n        </div>  \n        \n        <button\n          onClick={ () => {this.props.delTodoProp(this.props.id)} }\n        >\n          Delete\n        </button>\n      </li>\n    )\n  }\n};\n\n\n\nexport default TodoItem;\n// export default TodoItemWithLifecycleMethods\n\n// props.children:\n// gibt aus, was zwischen dem\n// öffnenden <TodoItem> und \n// schließenden </TodoItem> Tags steht\n\n\n\n  // Alternative zum ternären Operator hinsichtlich completedStyle\n\n  // let todoTextStyle = null;\n  // if(props.completed) {\n  //   todoTextStyle = completedStyle;\n  // }\n  // Entsprechend in span style \"todoTextStyle\" benutzen","//Aufgabe: Erstelle Component, die <p>Ich bin die TodoListe</p> ausgibt\n// fügt sie TodoContainer hinzu und rendert sie dort\nimport React from \"react\";\nimport TodoItem from \"../TodoItem/TodoItem.js\";\n\n// Prop in functional component\n// const TodoList = (props) => {\n\n//   console.log(props)\n// }; \n\nclass TodoList extends React.Component {\n\n  render() {\n    console.log(this.props);\n\n    // this.props.todos: Zugriff auf die\n    // prop \"todos\" => Zugriff auf todo-state bzw.-todo Array\n\n    //unique key/einmaliger key: Hilft sozusagen react\n    // effizienter zu arbeiten\n    return (\n      <ul>\n        {this.props.todosProp.map(todo => {\n          //console.log('todo.title in this.props.todosProp.map:', todo.title);\n          return (\n            <TodoItem \n              key={todo.id} \n              id={todo.id}\n              completed={todo.completed}\n              handleChangeProp={this.props.handleChangeProp}\n              delTodoProp={this.props.delTodoProp}\n            >\n              {todo.title/* wird als prop.children übergeben */} \n            </TodoItem>\n          );\n        })}\n      </ul>\n    )\n  }\n}\n\nexport default TodoList;\n\n\n// ERKLÄRUNGEN\n//todo parameter in map (this.props.todosProp.map(todo...)\n// beinhaltet immer das aktuelle todo-Object. Z.B:\n// {\n//   id: 1,\n//   title: \"React lernen\",\n//   completed: true\n// }\n\n\n// Object in constante\n// let todo = {\n//   id: 1,\n//   title: \"React lernen\",\n//   completed: true\n// }\n// alert( todo.completed );\n\n\n","import React, { Component, useState } from \"react\";\nimport { FaPlusCircle } from \"react-icons/fa\";\n\nimport \"./InputTodo.css\";\n\n\n// als functional component\nfunction InputTodo(props) {\n\n  // 1. Variable title => beinhaltet state \n  // 2. Variable setTitle => beinhaltet function zum Ändern des States\n  const [title, setTitle] = useState(\"\"); // setzt initial state title auf \"\"\n  // quasi gleichbedeutend mit\n  // const title = useState(\"\")[0];\n  // const setState = useState(\"\")[1];\n\n  const onChangeHandler = (e) => {\n    setTitle(e.target.value)\n  }\n\n  const handleSubmit = (e) => {\n    e.preventDefault(); // vermeide Abschicken des Formulars\n\n    console.log(title);\n\n    if (title.trim() !== \"\") { //Title ist nicht leer\n      props.addTodoProp(title.trim());\n\n      // Input Feld leeren\n      setTitle(\"\");\n\n    } else {\n      alert('Bitte Item reinschreiben!')\n    }\n\n  }\n\n\n  return (\n    <>\n      <form\n        onSubmit={handleSubmit}\n        className=\"form-container\"\n      >\n        <input\n          type=\"text\"\n          name=\"title\"\n          placeholder=\"Add Todo...\"\n          value={title}\n          onChange={onChangeHandler}\n          className=\"input-text\"\n        />\n        <button className=\"input-submit\">\n          <FaPlusCircle color=\"darkcyan\" size=\"20px\"  />\n        </button>\n\n      </form>\n    </>\n  )\n\n}\n\n\n\n// Class Component mit ES6 syntx (also mit constructor)\nclass InputTodoClass extends Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      title: \"\"\n    }\n  }\n  onChangeHandler = (e) => {\n    // [e.target.name] : dynamische Vergabe der Eigenschaft\n    // eines Objects\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  }\n\n  handleSubmit = (e) => {\n    e.preventDefault(); // vermeide Abschicken des Formulars\n    // console.log(this.state.title);\n\n    if (this.state.title.trim() !== \"\") { //Title ist nicht leer\n      this.props.addTodoProp(this.state.title.trim());\n\n      // Input Feld leeren\n      this.setState({\n        title: \"\"\n      });\n\n    } else {\n      alert('Bitte Item reinschreiben!')\n    }\n\n    // trim entfernt Whitespace (z.B. Leerzeichen) am Anfang\n    // und am Ende eines Strings und gibt diesen zurück\n  }\n\n  render() {\n    return (\n      <form\n        onSubmit={this.handleSubmit}\n        className=\"form-container\"\n      >\n        <input\n          type=\"text\"\n          name=\"title\"\n          placeholder=\"Add Todo...\"\n          value={this.state.title}\n          onChange={this.onChangeHandler}\n          className=\"input-text\"\n        />\n        <button className=\"input-submit\">Add +</button>\n      </form>\n    )\n  }\n}\nexport default InputTodo;\n\n// Exkurs: ES7 Syntax (wie im Tutorial)\n\nclass InputTodoEs7 extends Component {\n\n  state = {\n    title: \"\"\n  }\n\n  render() {\n    return (\n      <form>\n        <input type=\"text\" placeholder=\"Add Todo...\" />\n        <button>Submit</button>\n        Zugriff erfolgt auch mit this: {this.state.title}\n      </form>\n    )\n  }\n}\n","import React from \"react\";\n\n// Übersicht Class und Functional Component\n\nclass AlertButton extends React.Component {\n\n  // wenn wir einen state haben, können wir das im constructor() realiseren\n\n  clickHandler = () => {\n    alert(this.props.msg);\n    console.log(this.props.msg);\n  }\n\n  render() {\n    const buttonStyle = {\n      backgroundColor: \"red\",\n      color: \"white\",\n      borderRadius: \"15px\",\n      padding:\"10px\"\n    };\n    return (\n      <button\n        style={buttonStyle}\n        onClick={this.clickHandler}\n      >\n        {this.props.children}\n      </button>\n    );\n  }\n\n}\n\n// Realisiere obere Component als functional component\n\nconst AlertButtonFunc = (props) => {\n\n  const clickHandler = () => {\n    alert(props.msg);\n    console.log(props.msg);\n  };\n\n  const buttonStyle = {\n    backgroundColor: \"red\",\n    color: \"white\",\n    borderRadius: \"15px\",\n    padding:\"10px\"\n  };\n\n  return (\n    <button\n      style={buttonStyle}\n      onClick={clickHandler}\n    >\n      {props.children}\n    </button>\n  );\n}\n\nexport default AlertButton;\n// export default AlertButtonFunc;\n\n","const About = () => {\n  return <div>Hello from about page</div>\n};\n\nexport default About;","const NotMatch = () => {\n  return <h2>No Match for this page</h2>\n};\n\nexport default NotMatch;","import { NavLink } from \"react-router-dom\";\nimport \"./Navbar.css\";\n\nconst Navbar = () => {\n\n  const activeClass=\"active-menu-item\";\n  return(\n    <nav className=\"topNav\">\n      <ul>\n        <li><NavLink activeClassName={activeClass} to=\"/\" exact>Home</NavLink></li>\n        <li><NavLink activeClassName={activeClass} to=\"/about\">About</NavLink></li>\n        <li><NavLink activeClassName={activeClass} to=\"/contact\">Contact</NavLink></li>\n      </ul>\n    </nav>\n  );\n};\n\nexport default Navbar;\n\n// *** Erkärungen ***\n/*\n\nLinks mit <a> Element realisiert:\n<ul>\n  <li><a href=\"/\">Home</a></li>\n  <li><a href=\"/about\">About</a></li>\n  <li><a href=\"/contact\">Contact</a></li>\n</ul>\n\n=> Das würde dazu führen, dass die Seite immer komplett\nneu geladen wird. Wir wollen aber, dass nur die entsprechenden\npage-components gemountet oder entfernt werden\nLösung: React Router Components für die Navigation verwenden:\nLink oder NavLink\n\n\nLink vs Navlink\n- NavLink fügt unserem aktiven Menüpunkt eine\nCSS-Klasse hinzu. Aktiv bedeutet, dass die page\ndes Menüpunkts gerade angezeigt wird\n- mittels des props \"activeClassName\" können wir den Namen der\nKlasse ändern (standard ist \"active\")\n*/\n","const Contact = () => {\n  return <p>Hello from Contact</p>;\n}\n\nexport default Contact;","import React from \"react\";\nimport Header from \"../Header/Header.js\";\nimport Practice from \"../Practice/Practice.js\";\nimport TodoCount from \"../TodoCount/TodoCount.js\";\nimport TodoList from \"../TodoList/TodoList.js\";\nimport InputTodo from \"../InputTodo/InputTodo.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport \"./TodoContainer.css\";\nimport AlertButton from \"../Practice/AlertButton.js\";\nimport { Route, Switch } from \"react-router-dom\";\nimport About from \"../../pages/About.js\";\nimport NotMatch from \"../../pages/NotMatch.js\";\nimport Navbar from \"../Navbar/Navbar.js\";\nimport Contact from \"../../pages/Contact.js\";\n\n\nclass TodoContainer extends React.Component {\n\n  constructor() {\n    super();\n    this.state = {\n      todos: []\n    };\n  }\n\n\n  handleChange = (id) => {\n    console.log('checkbox clicked:', id);\n\n    //Wichtig: State niemals direkt ändern:\n    //this.state.todos = []; // SO NICHT\n\n    //Funktion zum Ändern des states\n    //erwartet ein Object als Parameter\n\n    //Schreibweise ohne Ternären Operator\n    this.setState({\n      todos: this.state.todos.map(todoObj => {\n        if (todoObj.id === id) {\n          return {\n            ...todoObj,\n            completed: !todoObj.completed\n          }\n        }\n        return todoObj;\n\n      }) // END of map\n    });\n\n    // Schreibweise mit Ternären Operator\n\n    // this.setState({\n    //   todos: this.state.todos.map( todoObj =>{\n    //     return {\n    //       ...todoObj,\n\n    //       // invertiere completed (false wird true und true wird false)\n    //       // wenn die ID des todoObj der id entspricht, die dem Handler (handleChange)\n    //       // übergeben wurde\n    //       completed: todoObj.id === id ? !todoObj.completed : todoObj.completed\n    //     }\n    //   })\n    // });\n\n\n    //❗Todo❗ in Zukunft: setState updater bzw callback benutzen\n    // Warum? Siehe unten bei Erklärungen\n  }\n\n  addTodo = (title) => {\n    console.log(title);\n\n    const newTodo = {\n      id: uuidv4(),\n      title: title,\n      completed: false\n    };\n    this.setState({\n      todos: [newTodo, ...this.state.todos]\n    });\n\n    // [...this.state.todos, newTodo]\n    // kopiert sozusagen unser todosArray und fügt\n    // unserer newTodo als erstes Element hinzu\n  }\n\n  delTodo = (id) => {\n\n    // hier speichern wir das state-obj\n    // in einer Variable\n\n    const newTodos = this.state.todos.filter(todo => {\n      return todo.id !== id;\n    });\n\n    this.setState({ todos: newTodos });\n\n    // Todo Zukunft: Hier eigentlich wieder besser: callback \n    // function als Parameter für setState\n  }\n  componentDidMount() {\n    // Erklärung siehe unten\n    console.log(\"%c ComponentDidMount aus TodoContainer ausgeführt\", \"background: #bada55\")\n\n    // Daten aus localStorage laden\n    const temp = localStorage.getItem(\"todos\");\n    const loadedTodos = JSON.parse(temp);\n\n    if (loadedTodos) { // loadedTodos ist nicht leer\n      this.setState({\n        todos: loadedTodos\n      })\n    }\n\n\n  }\n\n  componentDidUpdate(previousProps, previousState) {\n    // Erklärung zu componentDidUpdate siehe unten\n    console.log(\"%c componentDidUpdate aus TodoContainer asugeführt\", \"background: #bada55\")\n\n    // arrays können nicht direkt miteinander verglichen werden\n    // => if(previousState.todos !== this.state.todos) wäre IMMER true\n    // Stattdessen: Arrays ins String umwandeln \n    if (JSON.stringify(previousState.todos) !== JSON.stringify(this.state.todos)) {\n      // Hier ist es sinnvoll, die neuen Daten/State in einer Datenbank zu speichern\n      // in unserem Fall in localStorage\n      localStorage.setItem(\"todos\", JSON.stringify(this.state.todos))\n    }\n\n  }\n\n  render() {\n\n    return (\n      <>\n        <Navbar />\n        <Switch>\n          <Route path=\"/\" exact>\n            <div className=\"container\">\n              <div className=\"inner\">\n                <Header />\n                <InputTodo\n                  addTodoProp={this.addTodo}\n                />\n                <TodoList\n                  todosProp={this.state.todos}\n                  handleChangeProp={this.handleChange}\n                  delTodoProp={this.delTodo}\n                />\n                <TodoCount todosProp={this.state.todos} />\n                {/* <Practice /> */}\n\n              </div>\n            </div>\n          </Route>\n          <Route path=\"/about\">\n            <About />\n          </Route>\n          <Route path=\"/about\">\n            <About />\n          </Route>\n          <Route path=\"/contact\">\n            <Contact />\n          </Route>\n          <Route path=\"*\">\n            <NotMatch />\n          </Route>\n        </Switch>\n      </>\n    );\n  }\n\n}\n\n\nexport default TodoContainer;\n\n// ToDo Container umwandeln in Functional Component unter Verwendung\n// von useEffekt-Hook: siehe https://ibaslogic.com/react-hooks-tutorial/#using-the-react-hooks-usestate \n\n//********************\n// *** Erklärungen ***\n//********************\n\n// *** Ternärer Operator: ? : ***\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\n\n// let completed = todoObj.id === id ? !todoObj.completed : todoObj.completed\n\n// Obere Zeile ist gleichbedeutend mit folgendem Code\n\n// let completed = null;\n// if( todoObj.id === id ) {\n//   completed =!todoObj.completed\n// } else {\n//   completed = todoObj.completed;\n// }\n\n\n// *** ComponentDidMount ***\n// componentDidMount() {...}\n  // wird aufgerufen, wenn die Component \"gemountet\", \n  // also zum DOM hinzugefügt wurde\n\n  // Wozu verwenden: Netzwerkanfragen/Daten laden: \n  // z.B mit fetch:\n\n  // fetch(\"https://jsonplaceholder.typicode.com/todos?_limit=10\")\n  //   .then( response => {return response.json()} )\n  //   .then( data => {\n  //     //Todos aus jsonplaceholder unseres Todos hinzufügen\n  //     this.setState( {todos: [...data]} );\n  //   })\n\n// *** ComponentDidUpdate ***\n// componentDidUpdate(previousProps, previousState) {... }\n\n// componentDidUpdate wird ausgeführt, wenn die Komponente und \n// somit das DOM geändert wurde\n// previousProps enthält die vorherigen Props,also vor dem Update (hier: leer)\n// previousState enthält den vorherigen State,also vor dem Update\n\n\n// Wichtig: Am besten vergleicht man stets den ursprünglichen State mit dem neuen State,\n// damit man potenzielle Endless-Loops vermeidet. Vor allem wird das wichtig\n// wenn man setState in ComponentDidUpdate verwendet\n\n// *** React Router ***\n/*\n<Route path=\"/\">\nURL muss mit dem path (hier also \"/\") ANFANGEN, damit es einen\nMAtch gibt\n<Route path=\"/\" exact> Die Route muss EXAKT dem Path entsprechen\n\n* Route OHNE Switch*\n\n<Route path=\"/\" exact>...</Route>\n<Route path=\"/about\">...</Route>\n<Route path=\"/contact\">...</Route>\n\nAls Pseudocode:\n\nif(path === \"/\") {\n  render(IndexPage) // \"quasi index Seite\"\n}\nif(path === \"/about\") {\n  render(AboutPage)\n}\nif(path === \"/contact\") {\n  render(ContactPage)\n}\n\n* Route MIT Switch*\n\n<Switch>\n  <Route path=\"/\" exact>...</Route>\n  <Route path=\"/about\">...</Route>\n  <Route path=\"/contact\">...</Route>\n</Switch>\n\nif(path === \"/\") {\n  render(IndexPage) // \"quasi index Seite\"\n}\nelse if(path === \"/about\") {\n  render(AboutPage)\n}\nelse if(path === \"/contact\") {\n  render(ContactPage)\n}\n\n*/","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport TodoContainer from \"./components/TodoContainer/TodoContainer.js\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport \"./App.css\";\n//const reactElement = <p>Hallo aus index.js!</p>; // intern: React.createElement('h1',...)\n\n// Rendert unsere Components/React-Elemente im DOM\n// hier wird es an das HTML Element #root hinzugefügt \n// (siehe public -> index.html -> <body>)\nReactDOM.render(\n\n  <React.StrictMode>\n    <Router>\n      <TodoContainer />\n    </Router>\n  </React.StrictMode>, \n  document.getElementById('root') // Füge TodoContainer im DOM zum div mit ID \"root\" hinzu\n);\n\n\n// Erklärung\n\n/*\n<Router> // \"aktiviert\" sozusagen React Router\n  <TodoContainer />\n</Router>\n\nWir können nun Router in TodoContainer und all seinen Children\nverwenden \n\n*/"],"sourceRoot":""}